1. Как вы можете описать процесс распространения событий в JavaScript (Event Propagation)? Расскажите о его основных фазах.
Какие есть способы применения знаний о фазах распространения событий на практике?

Event Propagation это механизм, который определяет порядок, в котором элементы DOM получают уведомление о событии. 
Когда происходит событие (например, клик), оно проходит через несколько фаз, затрагивая сам элемент и его предков.

Процесс состоит из трех фаз, которые событие проходит последовательно.
1. Фаза захвата (Capture Phase)
Событие начинает свой путь от самого верхнего элемента в дереве DOM и последовательно спускается через всех предков целевого элемента,
пока не достигнет самого элемента.
Цель - захватить событие на пути к цели. Слушатели, зарегистрированные для этой фазы, срабатывают именно в этот момент.

2. Фаза цели (Target Phase)
Событие достигает самого элемента, на котором оно произошло (например, кнопки, на которую кликнули).
Цель - уведомить слушатели, привязанные непосредственно к целевому элементу. На этой фазе срабатывают слушатели, 
зарегистрированные как на захват, так и на всплытие.

3. Фаза всплытия (Bubbling Phase)
После фазы цели событие начинает подниматься обратно по дереву DOM, от непосредственного родителя целевого элемента и дальше вверх, 
через всех предков, до window.
Это фаза по умолчанию. Большинство слушателей событий срабатывают именно на этой фазе, если не указано иное.

Способы применения:
1. Делегирование событий (Event Delegation)
Когда в приложении много однотипных элементов (например, кнопки в меню), можно повесить один обработчик на общего родителя.
Когда событие происходит на одном из дочерних элементов, оно всплывает до этого родителя. В обработчике можно определить на каком
именно дочернем элементе произошел клик, используя event.target
Такое использование экономит память и автоматически работает с динамическими элементами.

2. Прекращение распространения (stopPropagation и stopImmediatePropagation)
С помощью event.stopPropagation() можно остановить движение события на текущей фазе. Если вызвать его в фазе захвата, событие не
дойдет до цели и всплытия. Если вызвать во всплытии - оно не пойдет выше.
С помощью event.stopImmediatePropagation() можно сделать тоже самое, но также предотвратить вызов других обработчиков, привязанных
к этому же элементу на этой же фазе.

3. Предотвращение поведения по умолчанию (preventDefault)
event.preventDefault() отменяет стандартное действие браузера, связанное с событием (например, при отправке формы)


2. Расскажите, что такое Promise в JavaScript, как он работает, какие основные состояния у него бывают? Каким еще способом можно
обработать асинхронный код? Какую роль в асинхронности играет событийный цикл (Event Loop)?

Promise это объект, представляющий результат асинхронно операции, которая может быть выполнена или не выполнена в будущем.
Основняе состояния Promise - pending (ожидание, начальное состояние), fulfilled (выполнено, успешное выполнение)
и rejected (отклонено, произошла ошибка).

Как работает
Сначала создается состояние pending, при успешном завершении переходит в fulfilled с результатом, при ошибке переходит в rejected
с причиной ошибки. Состояние меняется только один раз и не может быть изменено обратно.

Другие способы обратоки асинхронного кода:
1. Callback функции
2. Async/Await

Event Loop является механизмом, который позволяет обрабатывать асинхронные операции в JS.


3.Что такое ООП, и какие его ключевые принципы вы могли бы описать? При объяснении приводите примеры. 
Максимально подробно расскажите о том, как ООП реализовано в JavaScript.

ООП, или объектно ориентированное программирование, это подход, в котором приложение организовано как совокупность объектов,
которые взаимодействуют друг с другом. Каждый объект является экземпляром определенного класса.

Ключевые принципы ООП:
 - инкапсуляция, или объединение свойств и методов, которые работают с данными, в единый объект. Доступ к данным осуществляется
 через публичные методы для их защиты от некорректного изменения извне.
 class BankAccount {
    #balance = 0; // Приватное поле
  
    constructor(initialBalance) {
        this.#balance = initialBalance;
    }
  
    // Публичные методы для контролируемого доступа
    deposit(amount) {
        if (amount > 0) {
            this.#balance += amount;
        }
    }
  
    withdraw(amount) {
        if (amount > 0 && amount <= this.#balance) {
            this.#balance -= amount;
            return amount;
        }
        return 0;
    }
  
    getBalance() {
        return this.#balance;
    }
 }

const account = new BankAccount(1000);
account.deposit(500);
console.log(account.getBalance()); // 1500
// account.#balance = 10000; // Ошибка - приватное поле недоступно

 - наследование, или способность создавать новые классы на основе уже существующих. Эти новые классы автоматически получают
 свойства и методы родителя, что способствует повторному использованию кода.
 class Animal {
    constructor(name) {
        this.name = name;
    }
  
    speak() {
        console.log(`${this.name} издает звук`);
    }
  
    eat() {
        console.log(`${this.name} ест`);
    }
}

class Dog extends Animal {
    constructor(name, breed) {
        super(name); // Вызов конструктора родителя
        this.breed = breed;
    }
  
    // Переопределение метода
    speak() {
        console.log(`${this.name} лает: Гав-гав!`);
    }
  
    // Новый метод
    fetch() {
        console.log(`${this.name} приносит палку`);
    }
}

const myDog = new Dog("Бобик", "Лабрадор");
myDog.speak(); // "Бобик лает: Гав-гав!"
myDog.eat();   // "Бобик ест" (унаследован от Animal)
myDog.fetch(); // "Бобик приносит палку"

 - абстракция, или выделение главного и отбрасывание несущественных деталей.
 class CoffeeMachine {
    constructor() {
        this.waterTemperature = 20;
        this.coffeeAmount = 0;
    }
  
    #heatWater() {
        console.log("Нагрев воды...");
        this.waterTemperature = 95;
    }
  
    #grindCoffee() {
        console.log("Помол кофе...");
        this.coffeeAmount = 15;
    }
  
    #brewCoffee() {
        console.log("Приготовление кофе...");
        return "Готовый кофе";
    }
  
    // Простой публичный интерфейс
    makeCoffee() {
        this.#grindCoffee();
        this.#heatWater();
        return this.#brewCoffee();
    }
}

const machine = new CoffeeMachine();
const coffee = machine.makeCoffee(); // Пользователю не нужно знать о внутренних процессах
console.log(coffee); // "Готовый кофе"

 - полиморфизм, или способность объектов с общими методами вести себя по-разному в зависимости от своего типа.
 class Cat extends Animal {
    speak() {
        console.log(`${this.name} мяукает: Мяу!`);
    }
}

class Cow extends Animal {
    speak() {
        console.log(`${this.name} мычит: Мууу!`);
    }
}

// Полиморфизм в действии
const animals = [
    new Dog("Шарик", "Дворняжка"),
    new Cat("Мурка", "Сиамская"),
    new Cow("Зорька", "Голштинская")
];

animals.forEach(animal => {
    animal.speak(); // Каждое животное издает свой звук
});
// Шарик лает: Гав-гав!
// Мурка мяукает: Мяу!
// Зорька мычит: Мууу!

В JS ООП реализован через прототипное наследование. Каждый объект имеет ссылку на другой объект - свой прототип, от которого он может
наследовать свойства и методы. Реализовать можно с помощью классов, где есть конструктор (метод, который вызывается при создании
нового объекта), методы (функции, которые определяют поведение объектов) и наследование (классы могут наследовать свойства и методы
от других классов).


4. Опишите максимально детально, как браузер обрабатывает URL, начиная с момента его ввода в адресную строку и заканчивая
отображением страницы. Какие технологии позволяют ускорить процесс? Какие проблемы (безопастность, междоменное взаимодействие) 
могут возникать в процессе?

1) Пользователь вводит какой-то урл, браузер разбирает его на компоненты (например, protocol, hostname, hash).
2) Браузер проверяет кэш. Процесс проверки:
Кэш Service Worker => HTTP-кэш => Память браузера
Проверяются заголовки: Cache-Control, ETag, Last-Modified
Если ресурс свежий, используется из кэша
3) DNS-запрос. 
4) Установка TCP-соединения. Браузер использует полученный IP-адрес для установления соединения с сервером, на котором размещен сайт.
5) Отправка HTTP-запроса. После установления соединения отправляется HTTP-запрос на сервер. Он содержит информацию о
запрошенном ресурсе и метаданные (например, тип браузера).
6) Обработка зап сервером. Сервер получает запрос, обрабатывает его, находит нужную страницу и отправляет его обратно в виде 
HTTP-ответа.
7) Отображение страницы. Браузер получает HTTP-ответ, который содержит HTML страницы, парсит его и строит DOM-дерево.
Во время парсинга браузер находит ссылки на другие ресурсы (изображения, CSS файлы, JS файлы) и загружает их.
Далее браузер применяет стили из найденных CSS файлов, выполняет JS код и отображает готовую страницу пользователю.

Технологии для ускорения:
 - кэширование
 - оптимизация загрузки JS

Возможные проблемы:
 - проблемы кэширования DNS (устаревшие записи, проблемы с обновлением DNS)
 - междоменные ограничения 
 - проблемы с cookies
 - смешанный контент (возникает, когда безопасная HTTPS страница загружает небезопасныее HTTP ресурсы, что создает уязвимость, т.к.
 злоумышленник может перехватить или подменить ресурсы)
 - CSP нарушения (при неправильной настройке политик может волникнуть блокировка контента и нарушения функциональности сайта)